package plu.teamtwo.rtm.expiriments;

import com.google.gson.Gson;
import plu.teamtwo.rtm.neat.Encoding;
import plu.teamtwo.rtm.neat.Genome;
import plu.teamtwo.rtm.neat.NEATController;
import plu.teamtwo.rtm.neat.ScoringFunction;

import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.BitSet;

public class XORTest {
    private static final int TOTAL_ROUNDS = 100;

    public static void main(String[] args) {
        PrintStream output = new PrintStream(new FileOutputStream(FileDescriptor.out));
        NEATController controller = new NEATController(
                Encoding.DIRECT_ENCODING,
                3, 1
        );

        controller.createFirstGeneration();

        for(int g = 0; g < 100; ++g) {
            controller.assesGeneration(new XORScore());
            final Genome best = controller.getBestIndividual();
            System.out.println(String.format("Gen %d: %.2f, %.2f, %.0f", controller.getGenerationNum(), controller.getFitness(), controller.getAdjFitness(), best.getFitness()));
            if(best.getFitness() >= 99.5f) {
                Gson gson = new Gson();
                System.out.println(gson.toJson(best));
                return;
            }
            controller.nextGeneration();
        }
//        try {
//            NEATController.writeToStream(controller, output);
//        } catch(IOException e) {
//            System.err.println(e.getMessage());
//        }
    }


    private static class XORScore implements ScoringFunction {
        private int rounds = TOTAL_ROUNDS;
        private float score = 0;
        private boolean expected;

        /**
         * This will be called to determine how many simultaneous instances of the function can exist.
         *
         * @return The maximum number of threads or 0 if there is no reasonable limit.
         */
        @Override
        public int getMaxThreads() {
            return 1;
        }


        /**
         * This function will be called for once for every individual which is being evaluated. Each scoring function
         * can thus use its own data and know that it will be called with information about only one individual even in a
         * multithreaded context. This should act as a constructor since the caller will not know what subtype it is.
         *
         * @return A new scoring function in the initial state.
         */
        @Override
        public ScoringFunction createNew() {
            return new XORScore();
        }


        /**
         * This function will be called to retrieve the inputs which should be used by the network. This will be called
         * until it returns null, signaling the end of inputs.
         *
         * @return An array of output values.
         */
        @Override
        public float[] generateInput() {
            if(--rounds < 0) return null;

            float a = Math.round(Math.random());
            float b = Math.round(Math.random());
            expected = ((int)a ^ (int)b) == 1;

            return new float[]{1.0f, a, b};
        }


        /**
         * This function will be called with the outputs generated by the neural network after being feed the input from
         * generateInput().
         *
         * @param output Array of output values generated by the network.
         */
        @Override
        public void acceptOutput(float[] output) {
            //score += 1.0f - Math.abs(expected - output[0]);
            if(output[0] >= 0.5 == expected)
                score += 1.0f;
        }


        /**
         * This function will be called to asses the performance of the neural network. This function will not be called
         * until generateInput() returns null.
         *
         * @return A score which can be used to asses the fitness of the specified individual.
         */
        @Override
        public float getScore() {
            return score;
        }
    }
}

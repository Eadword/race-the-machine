package plu.teamtwo.rtm.neat;

import java.util.BitSet;

public class XORTest {

    private static class XORScore implements ScoringFunction {
        public static final int INPUT_PAIRS_PER_ROUND = 1;
        public static final int TOTAL_ROUNDS = 100;

        private int rounds = TOTAL_ROUNDS;
        private int correct = 0;
        private BitSet expected;

        /**
         * This will be called to determine how many simultaneous instances of the function can exist.
         *
         * @return The maximum number of threads or 0 if there is no reasonable limit.
         */
        @Override
        public int getMaxThreads() {
            return 1;
        }


        /**
         * This function will be called for once for every individual which is being evaluated. Each scoring function
         * can thus use its own data and know that it will be called with information about only one individual even in a
         * multithreaded context. This should act as a constructor since the caller will not know what subtype it is.
         *
         * @return A new scoring function in the initial state.
         */
        @Override
        public ScoringFunction createNew() {
            return new XORScore();
        }


        /**
         * This function will be called to retrieve the inputs which should be used by the network. This will be called
         * until it returns null, signaling the end of inputs.
         *
         * @return An array of output values.
         */
        @Override
        public float[] generateInput() {
            if(rounds <= 0) return null;
            float[] inputs = new float[INPUT_PAIRS_PER_ROUND * 2];
            expected = new BitSet(INPUT_PAIRS_PER_ROUND);

            for(int i = 0; i < INPUT_PAIRS_PER_ROUND; ++i) {
                final int j = i*2;
                inputs[j] = Math.round(Math.random());
                inputs[j+1] = Math.round(Math.random());
                expected.set(i, ((int)inputs[j] ^ (int)inputs[j+1]) == 1);
            }

            return inputs;
        }


        /**
         * This function will be called with the outputs generated by the neural network after being feed the input from
         * generateInput().
         *
         * @param output Array of output values generated by the network.
         */
        @Override
        public void acceptOutput(float[] output) {
            for(int i = 0; i < INPUT_PAIRS_PER_ROUND; i++) {
                final boolean val = output[i] >= 0.5;
                if(val == expected.get(i))
                    correct++;
            }
        }


        /**
         * This function will be called to asses the performance of the neural network. This function will not be called
         * until generateInput() returns null.
         *
         * @return A score which can be used to asses the fitness of the specified individual.
         */
        @Override
        public float getScore() {
            return (float)Math.pow(correct, 2);
        }
    }
}
